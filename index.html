<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Planner - Trucks, Cars & Hikers</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .input-section {
            background: white;
            padding: 1rem;
            border-bottom: 1px solid #ddd;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: flex-end;
        }

        .input-group {
            flex: 1;
            min-width: 200px;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: #555;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #3498db;
        }

        .truck-fields {
            display: none;
        }

        .truck-fields.visible {
            display: block;
        }

        .map-click-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 200px;
        }

        .map-click-controls h3 {
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
            color: #2c3e50;
        }

        .click-mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .click-mode-btn {
            padding: 0.5rem;
            border: 2px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .click-mode-btn:hover {
            background: #f5f5f5;
        }

        .click-mode-btn.active {
            border-color: #3498db;
            background: #e3f2fd;
            font-weight: 600;
        }

        .click-mode-btn.start.active {
            border-color: #2ecc71;
            background: #d4edda;
        }

        .click-mode-btn.end.active {
            border-color: #e74c3c;
            background: #f8d7da;
        }

        .click-mode-btn.via.active {
            border-color: #9b59b6;
            background: #e7d5f0;
        }

        .via-points-list {
            margin-top: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .via-point-item {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            background: #f8f9fa;
            border-left: 3px solid #9b59b6;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .via-point-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .via-point-remove {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .via-point-remove:hover {
            background: #c0392b;
        }

        .btn {
            padding: 0.5rem 1.5rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #2980b9;
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: 350px;
            background: white;
            border-left: 1px solid #ddd;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .sidebar-section {
            padding: 1rem;
            border-bottom: 1px solid #eee;
        }

        .sidebar-section h2 {
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            color: #2c3e50;
        }

        .route-summary {
            background: #ecf0f1;
            padding: 0.75rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .route-summary-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .route-summary-item:last-child {
            margin-bottom: 0;
        }

        .rest-stop-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .rest-stop-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-left: 4px solid;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .rest-stop-item:hover {
            transform: translateX(4px);
        }

        .rest-stop-item.break {
            border-color: #f39c12;
        }

        .rest-stop-item.daily {
            border-color: #e74c3c;
        }

        .rest-stop-item.weekly {
            border-color: #9b59b6;
        }

        .rest-stop-item.parking {
            border-color: #27ae60;
        }

        .rest-stop-item.hiker-rest {
            border-color: #3498db;
        }

        .rest-stop-item.hiker-rest-alt {
            border-color: #5dade2;
        }

        .rest-stop-item.axle-warning {
            border-color: #f1c40f;
            background: #fef9e7;
        }

        .rest-stop-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .rest-stop-details {
            font-size: 0.85rem;
            color: #666;
        }

        .axle-warning-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #fef9e7;
            border-left: 4px solid #f1c40f;
            border-radius: 4px;
        }

        .axle-warning-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 0.25rem;
        }

        .axle-warning-text {
            font-size: 0.85rem;
            color: #856404;
        }

        .country-warning {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            border-left: 4px solid;
        }

        .country-warning.norway {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .country-warning.sweden {
            background: #fff3e0;
            border-color: #ff9800;
        }

        .country-warning.denmark {
            background: #ffebee;
            border-color: #f44336;
        }

        .country-warning.finland {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .country-warning-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .country-warning-text {
            font-size: 0.85rem;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.2);
        }

        .legend-color.break {
            background: #f39c12;
        }

        .legend-color.daily {
            background: #e74c3c;
        }

        .legend-color.weekly {
            background: #9b59b6;
        }

        .legend-color.parking {
            background: #27ae60;
        }

        .legend-color.hiker-rest {
            background: #3498db;
        }

        .legend-color.hiker-rest-alt {
            background: #5dade2;
        }

        .legend-color.axle-warning {
            background: #f1c40f;
        }

        .legend-color.water {
            background: #3498db;
        }

        .rest-stop-item.water {
            border-color: #3498db;
        }

        .rest-stop-item.daily-segment {
            border-color: #16a085;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 1rem;
            margin: 1rem;
            border-radius: 4px;
            border-left: 4px solid #c33;
        }

        .disclaimer {
            padding: 1rem;
            background: #fff3cd;
            border-top: 1px solid #ddd;
            font-size: 0.85rem;
            color: #856404;
        }

        .disclaimer strong {
            display: block;
            margin-bottom: 0.5rem;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è Route Planner</h1>
            <p>Mandatory Rest Stops for Trucks, Cars & Hikers</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="vehicleType">Vehicle Type</label>
                <select id="vehicleType">
                    <option value="truck" selected>Truck</option>
                    <option value="car">Car</option>
                    <option value="hiker">Hiker</option>
                    <option value="bike">Cyclist</option>
                </select>
                
                <div class="routing-service-config" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em;">
                    <label for="orsApiKey" style="display: block; margin-bottom: 5px;">
                        <strong>OpenRouteService API Key (Optional)</strong>
                    </label>
                    <input type="text" id="orsApiKey" placeholder="Leave empty to use OSRM (free, no key needed)" 
                           style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px;">
                    <p style="margin: 5px 0 0 0; color: #666; font-size: 0.85em;">
                        Get free key at <a href="https://openrouteservice.org/dev/#/signup" target="_blank">openrouteservice.org</a> 
                        (2000 requests/day). Enables automatic exclusion of unsafe roads for hikers/cyclists.
                    </p>
                </div>
            </div>
            <div class="input-group">
                <label for="startAddress">Start Address</label>
                <input type="text" id="startAddress" placeholder="e.g., Oslo, Norway">
            </div>
            <div class="input-group">
                <label for="destinationAddress">Destination Address</label>
                <input type="text" id="destinationAddress" placeholder="e.g., Stockholm, Sweden">
            </div>
            <div class="input-group">
                <label for="departureTime">Departure Time</label>
                <input type="datetime-local" id="departureTime">
            </div>
            <div class="input-group truck-fields" id="truckFields">
                <label for="totalWeight">Total Weight (tonnes)</label>
                <input type="number" id="totalWeight" step="0.1" min="0" placeholder="e.g., 40">
            </div>
            <div class="input-group truck-fields" id="truckFields2">
                <label for="axleLoad">Axle Load (tonnes per axle)</label>
                <input type="number" id="axleLoad" step="0.1" min="0" placeholder="e.g., 10">
            </div>
            <div class="input-group truck-fields" id="truckFields3">
                <label for="numAxles">Number of Axles</label>
                <input type="number" id="numAxles" min="2" value="2" placeholder="e.g., 2">
            </div>
            <div class="input-group">
                <button class="btn" id="calculateBtn">Calculate Route</button>
            </div>
            <div class="input-group">
                <button class="btn" id="exportGpxBtn" style="background: #27ae60;" disabled>Export to GPX</button>
            </div>
        </div>

        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
                <div class="map-click-controls">
                    <h3>Click on Map to Set:</h3>
                    <div class="click-mode-buttons">
                        <button class="click-mode-btn start" id="clickModeStart" data-mode="start">üìç Start Location</button>
                        <button class="click-mode-btn end" id="clickModeEnd" data-mode="end">üéØ End Location</button>
                        <button class="click-mode-btn via" id="clickModeVia" data-mode="via">‚ûï Via Point</button>
                        <button class="click-mode-btn" id="clickModeOff" data-mode="off">‚ùå Disable</button>
                    </div>
                    <div class="via-points-list" id="viaPointsList" style="display: none;">
                        <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: #555;">Via Points:</div>
                        <div id="viaPointsContainer"></div>
                    </div>
                </div>
                <div class="loading" id="loading" style="display: none;">
                    <div class="loading-spinner"></div>
                    <div id="loadingText">Calculating route...</div>
                </div>
            </div>

            <div class="sidebar">
                <div class="sidebar-section">
                    <h2>Route Summary</h2>
                    <div id="routeSummary">
                        <p style="color: #999;">Enter addresses and click Calculate Route</p>
                    </div>
                </div>

                <div class="sidebar-section" id="axleWarningsSection" style="display: none;">
                    <h2>Axle Load Warnings</h2>
                    <div id="axleWarnings">
                        <p style="color: #999;">No warnings</p>
                    </div>
                </div>

                <div class="sidebar-section" id="safetyWarningsSection" style="display: none;">
                    <h2>Safety Warnings</h2>
                    <div id="safetyWarnings">
                        <p style="color: #999;">No warnings</p>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h2>Rest Stops</h2>
                    <div id="restStopsList">
                        <p style="color: #999;">No route calculated yet</p>
                    </div>
                </div>

                <div class="sidebar-section" id="countryWarningsSection">
                    <h2>Country Warnings</h2>
                    <div id="countryWarnings">
                        <p style="color: #999;">Will appear after route calculation</p>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h2>Legend</h2>
                    <div class="legend" id="legend">
                        <!-- Legend items will be populated dynamically -->
                    </div>
                </div>

                <div class="disclaimer">
                    <strong>‚ö†Ô∏è Disclaimer</strong>
                    <p>This tool is for planning purposes only. Always verify local regulations, road restrictions, and obtain necessary permissions. Rules vary by country and region. Parking spot suggestions are based on OpenStreetMap data and may not be accurate or legal. Always respect private property and local laws. Axle load restrictions are based on OSM data and should be verified with local authorities.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // Initialize map
        const map = L.map('map').setView([60, 10], 4);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        // State
        let routeData = null;
        let markers = [];
        let routePolyline = null;
        let countryRules = {};
        let vehicleType = 'truck';
        let truckSpecs = { totalWeight: 0, axleLoad: 0, numAxles: 2 };
        let clickMode = 'off'; // 'start', 'end', 'via', 'off'
        let startMarker = null;
        let endMarker = null;
        let viaMarkers = [];
        let viaPoints = []; // Array of {lat, lon, name}
        let addedWaterPoints = []; // Track water points to ensure minimum distance
        let addedHuts = []; // Track huts/shelters to ensure minimum distance
        let orsApiKey = ''; // OpenRouteService API key (optional)
        let isCalculating = false; // Flag to track if route calculation is in progress
        let calculationId = 0; // Incrementing ID to track calculation generations

        // Country-specific rules (for trucks/cars)
        const COUNTRY_RULES = {
            'Norway': {
                class: 'norway',
                rules: '2 nights max, 150m from houses. Right to roam (Allemannsretten) applies.'
            },
            'Sweden': {
                class: 'sweden',
                rules: '1-2 nights, out of sight from houses. Right to roam (Allemansr√§tten) applies.'
            },
            'Denmark': {
                class: 'denmark',
                rules: 'WARNING: Designated sites only or permission required. Wild camping generally not allowed.'
            },
            'Finland': {
                class: 'finland',
                rules: 'Short periods allowed, keep distance from homes. Everyman\'s right (Jokamiehenoikeus) applies.'
            }
        };

        // Vehicle type colors for route
        const VEHICLE_COLORS = {
            truck: '#e74c3c',
            car: '#3498db',
            hiker: '#27ae60',
            bike: '#e67e22'
        };

        // Set default departure time to now
        document.getElementById('departureTime').value = new Date().toISOString().slice(0, 16);

        // Event listeners
        document.getElementById('vehicleType').addEventListener('change', handleVehicleTypeChange);
        document.getElementById('calculateBtn').addEventListener('click', calculateRoute);
        document.getElementById('exportGpxBtn').addEventListener('click', exportToGPX);
        
        // Cancel calculation when inputs change
        document.getElementById('startAddress').addEventListener('input', cancelCalculation);
        document.getElementById('destinationAddress').addEventListener('input', cancelCalculation);
        document.getElementById('departureTime').addEventListener('change', cancelCalculation);
        
        // Initialize truck fields visibility on page load
        handleVehicleTypeChange();
        document.getElementById('orsApiKey').addEventListener('input', function() {
            orsApiKey = this.value.trim();
            // Store in localStorage for convenience
            if (orsApiKey) {
                localStorage.setItem('orsApiKey', orsApiKey);
            } else {
                localStorage.removeItem('orsApiKey');
            }
        });
        
        // Load API key from localStorage if available
        const savedApiKey = localStorage.getItem('orsApiKey');
        if (savedApiKey) {
            document.getElementById('orsApiKey').value = savedApiKey;
            orsApiKey = savedApiKey;
        }
        
        // Map click mode buttons
        document.querySelectorAll('.click-mode-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                clickMode = this.dataset.mode;
                updateClickModeButtons();
            });
        });
        
        // Map click handler
        map.on('click', handleMapClick);

        // Handle vehicle type change
        function handleVehicleTypeChange() {
            vehicleType = document.getElementById('vehicleType').value;
            const truckFields = document.querySelectorAll('.truck-fields');
            
            if (vehicleType === 'truck') {
                truckFields.forEach(field => field.classList.add('visible'));
            } else {
                truckFields.forEach(field => field.classList.remove('visible'));
            }

            // Update legend
            updateLegend();
            
            // Clear current route
            clearMap();
            document.getElementById('routeSummary').innerHTML = '<p style="color: #999;">Enter addresses and click Calculate Route</p>';
            document.getElementById('restStopsList').innerHTML = '<p style="color: #999;">No route calculated yet</p>';
            document.getElementById('axleWarningsSection').style.display = 'none';
            document.getElementById('exportGpxBtn').disabled = true;
        }

        // Update legend based on vehicle type
        function updateLegend() {
            const legend = document.getElementById('legend');
            let html = '';

            if (vehicleType === 'truck' || vehicleType === 'car') {
                html = `
                    <div class="legend-item">
                        <div class="legend-color break"></div>
                        <span>45-min Break</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color daily"></div>
                        <span>Daily Rest (11h)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color weekly"></div>
                        <span>Weekly Rest (45h)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color parking"></div>
                        <span>Suitable Parking</span>
                    </div>
                `;
                if (vehicleType === 'truck') {
                    html += `
                        <div class="legend-item">
                            <div class="legend-color axle-warning"></div>
                            <span>Axle Load Warning</span>
                        </div>
                    `;
                }
            } else if (vehicleType === 'hiker') {
                html = `
                    <div class="legend-item">
                        <div class="legend-color daily-segment"></div>
                        <span>Daily Segment (40 km)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color hiker-rest"></div>
                        <span>Rest (11.295 km)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color hiker-rest-alt"></div>
                        <span>Alternative Rest (2.275 km)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color water"></div>
                        <span>Drinking Water</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color parking"></div>
                        <span>Shelters/Huts/Camping</span>
                    </div>
                `;
            } else if (vehicleType === 'bike') {
                html = `
                    <div class="legend-item">
                        <div class="legend-color daily-segment"></div>
                        <span>Daily Segment (70 km)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color segment-break"></div>
                        <span>Segment Break (17 km)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color water"></div>
                        <span>Drinking Water</span>
                    </div>
                `;
            }

            legend.innerHTML = html;
        }

        // Initialize legend
        updateLegend();

        // Update click mode buttons
        function updateClickModeButtons() {
            document.querySelectorAll('.click-mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === clickMode) {
                    btn.classList.add('active');
                }
            });
            
            // Show/hide via points list
            const viaList = document.getElementById('viaPointsList');
            if (viaPoints.length > 0) {
                viaList.style.display = 'block';
            } else {
                viaList.style.display = 'none';
            }
        }

        // Handle map click
        async function handleMapClick(e) {
            if (clickMode === 'off') return;
            
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            
            // Show loading
            const loadingDiv = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            loadingDiv.style.display = 'block';
            loadingText.textContent = 'Getting address...';
            
            try {
                // Reverse geocode to get address
                await delay(1000); // Rate limiting
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`,
                    {
                        headers: {
                            'User-Agent': 'RoutePlanner/1.0'
                        }
                    }
                );
                const data = await response.json();
                const address = data.display_name || `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
                
                if (clickMode === 'start') {
                    // Remove old start marker
                    if (startMarker) {
                        map.removeLayer(startMarker);
                    }
                    
                    // Add new start marker
                    startMarker = L.marker([lat, lon], {
                        icon: L.divIcon({
                            className: 'start-marker',
                            html: '<div style="background: #2ecc71; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 0 2px #2ecc71;"></div>',
                            iconSize: [20, 20]
                        })
                    }).addTo(map);
                    startMarker.bindPopup(`<strong>Start</strong><br>${address}`).openPopup();
                    
                    // Update input field
                    document.getElementById('startAddress').value = address;
                    
                } else if (clickMode === 'end') {
                    // Remove old end marker
                    if (endMarker) {
                        map.removeLayer(endMarker);
                    }
                    
                    // Add new end marker
                    endMarker = L.marker([lat, lon], {
                        icon: L.divIcon({
                            className: 'end-marker',
                            html: '<div style="background: #e74c3c; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 0 2px #e74c3c;"></div>',
                            iconSize: [20, 20]
                        })
                    }).addTo(map);
                    endMarker.bindPopup(`<strong>End</strong><br>${address}`).openPopup();
                    
                    // Update input field
                    document.getElementById('destinationAddress').value = address;
                    
                } else if (clickMode === 'via') {
                    // Add via point
                    const viaPoint = { lat, lon, name: address };
                    viaPoints.push(viaPoint);
                    
                    // Add via marker
                    const viaMarker = L.marker([lat, lon], {
                        icon: L.divIcon({
                            className: 'via-marker',
                            html: '<div style="background: #9b59b6; width: 18px; height: 18px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 0 2px #9b59b6;"></div>',
                            iconSize: [18, 18]
                        })
                    }).addTo(map);
                    viaMarker.bindPopup(`<strong>Via Point</strong><br>${address}`);
                    viaMarkers.push(viaMarker);
                    
                    // Update via points list
                    updateViaPointsList();
                    // Cancel ongoing calculation when via points are added
                    cancelCalculation();
                }
                
            } catch (error) {
                console.error('Reverse geocoding failed:', error);
                // Still add marker with coordinates
                const coords = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
                
                if (clickMode === 'start') {
                    if (startMarker) map.removeLayer(startMarker);
                    startMarker = L.marker([lat, lon]).addTo(map);
                    startMarker.bindPopup(`<strong>Start</strong><br>${coords}`).openPopup();
                    document.getElementById('startAddress').value = coords;
                } else if (clickMode === 'end') {
                    if (endMarker) map.removeLayer(endMarker);
                    endMarker = L.marker([lat, lon]).addTo(map);
                    endMarker.bindPopup(`<strong>End</strong><br>${coords}`).openPopup();
                    document.getElementById('destinationAddress').value = coords;
                } else if (clickMode === 'via') {
                    viaPoints.push({ lat, lon, name: coords });
                    const viaMarker = L.marker([lat, lon]).addTo(map);
                    viaMarker.bindPopup(`<strong>Via Point</strong><br>${coords}`);
                    viaMarkers.push(viaMarker);
                    updateViaPointsList();
                    // Cancel ongoing calculation when via points are added
                    cancelCalculation();
                }
            } finally {
                loadingDiv.style.display = 'none';
            }
        }

        // Update via points list UI
        function updateViaPointsList() {
            const container = document.getElementById('viaPointsContainer');
            container.innerHTML = viaPoints.map((point, index) => `
                <div class="via-point-item">
                    <span class="via-point-name" title="${point.name}">${point.name}</span>
                    <button class="via-point-remove" onclick="removeViaPoint(${index})">Remove</button>
                </div>
            `).join('');
            updateClickModeButtons();
        }

        // Remove via point
        function removeViaPoint(index) {
            if (index >= 0 && index < viaPoints.length) {
                // Remove marker
                if (viaMarkers[index]) {
                    map.removeLayer(viaMarkers[index]);
                    viaMarkers.splice(index, 1);
                }
                // Remove point
                viaPoints.splice(index, 1);
                updateViaPointsList();
                // Cancel ongoing calculation when via points change
                cancelCalculation();
            }
        }
        
        // Make removeViaPoint available globally
        window.removeViaPoint = removeViaPoint;

        // Haversine formula for distance calculation
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Delay function for rate limiting
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Geocode address using Nominatim
        async function geocodeAddress(address) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json&limit=1`,
                    {
                        headers: {
                            'User-Agent': 'RoutePlanner/1.0'
                        }
                    }
                );
                const data = await response.json();
                if (data.length === 0) {
                    throw new Error(`Address not found: ${address}`);
                }
                return {
                    lat: parseFloat(data[0].lat),
                    lon: parseFloat(data[0].lon),
                    displayName: data[0].display_name
                };
            } catch (error) {
                throw new Error(`Geocoding failed: ${error.message}`);
            }
        }

        // Country cache to avoid redundant API calls for nearby coordinates
        const countryCache = new Map();
        const CACHE_RADIUS = 0.01; // ~1km radius for cache hits

        // Helper function to generate cache key from coordinates (rounded to cache radius)
        function getCacheKey(lat, lon) {
            const roundedLat = Math.round(lat / CACHE_RADIUS) * CACHE_RADIUS;
            const roundedLon = Math.round(lon / CACHE_RADIUS) * CACHE_RADIUS;
            return `${roundedLat.toFixed(4)},${roundedLon.toFixed(4)}`;
        }

        // Reverse geocode to get country (with caching)
        async function getCountry(lat, lon, skipDelay = false) {
            // Check cache first
            const cacheKey = getCacheKey(lat, lon);
            if (countryCache.has(cacheKey)) {
                return countryCache.get(cacheKey);
            }

            try {
                if (!skipDelay) {
                    await delay(1000); // Rate limiting (only when not batching)
                }
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`,
                    {
                        headers: {
                            'User-Agent': 'RoutePlanner/1.0'
                        }
                    }
                );
                const data = await response.json();
                const country = data.address?.country || 'Unknown';
                
                // Cache the result
                countryCache.set(cacheKey, country);
                return country;
            } catch (error) {
                console.error('Reverse geocoding failed:', error);
                return 'Unknown';
            }
        }

        // Get route from OpenRouteService (supports road exclusions)
        // Supports multiple via points - all via points are included in order: start -> via1 -> via2 -> ... -> viaN -> destination
        async function getRouteOpenRouteService(startLat, startLon, destLat, destLon, viaPoints = [], vehicleType) {
            try {
                let profile;
                if (vehicleType === 'hiker') {
                    profile = 'foot-walking';
                } else if (vehicleType === 'bike') {
                    profile = 'cycling-regular';
                } else {
                    profile = 'driving-car';
                }
                
                // Build coordinates array: [lon, lat] format
                // Order: start -> all via points (in order) -> destination
                const coordinates = [[startLon, startLat]];
                viaPoints.forEach(via => {
                    coordinates.push([via.lon, via.lat]);
                });
                coordinates.push([destLon, destLat]);
                
                // For hikers and cyclists, exclude unsafe roads
                const requestBody = {
                    coordinates: coordinates,
                    format: 'geojson'
                };
                
                // Add road exclusions for hikers and cyclists
                if (vehicleType === 'hiker' || vehicleType === 'bike') {
                    requestBody.options = {
                        avoid_features: ['highways', 'tollways']
                    };
                }
                
                const headers = {
                    'Content-Type': 'application/json'
                };
                
                // OpenRouteService uses Authorization header with API key
                if (orsApiKey) {
                    headers['Authorization'] = orsApiKey;
                }
                
                const response = await fetch(
                    `https://api.openrouteservice.org/v2/directions/${profile}`,
                    {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(requestBody)
                    }
                );
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Convert OpenRouteService format to OSRM-like format for compatibility
                if (data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    return {
                        code: 'Ok',
                        routes: [{
                            geometry: route.geometry,
                            distance: route.summary.distance,
                            duration: route.summary.duration,
                            legs: route.segments ? route.segments.map(seg => ({
                                distance: seg.distance,
                                duration: seg.duration
                            })) : []
                        }]
                    };
                } else {
                    throw new Error('No route found');
                }
            } catch (error) {
                throw new Error(`OpenRouteService routing failed: ${error.message}`);
            }
        }

        // Get route from OSRM (supports multiple waypoints)
        // Supports multiple via points - all via points are included in order: start -> via1 -> via2 -> ... -> viaN -> destination
        async function getRoute(startLat, startLon, destLat, destLon, viaPoints = [], alternatives = false) {
            try {
                let profile;
                if (vehicleType === 'hiker') {
                    profile = 'foot';
                } else if (vehicleType === 'bike') {
                    profile = 'cycling';
                } else {
                    profile = 'driving';
                }
                
                // Build waypoints string: start;via1;via2;...;viaN;destination
                // Order: start -> all via points (in order) -> destination
                let waypoints = `${startLon},${startLat}`;
                viaPoints.forEach(via => {
                    waypoints += `;${via.lon},${via.lat}`;
                });
                waypoints += `;${destLon},${destLat}`;
                
                const alternativesParam = alternatives ? '&alternatives=true&number=3' : '';
                const response = await fetch(
                    `https://router.project-osrm.org/route/v1/${profile}/${waypoints}?overview=full&geometries=geojson${alternativesParam}`
                );
                const data = await response.json();
                if (data.code !== 'Ok') {
                    throw new Error('Route calculation failed');
                }
                return data;
            } catch (error) {
                throw new Error(`Routing failed: ${error.message}`);
            }
        }

        // Find safer route by checking alternatives
        async function findSaferRoute(startLat, startLon, destLat, destLon, viaPoints, vehicleType) {
            try {
                // If OpenRouteService API key is provided, use it (automatically excludes unsafe roads)
                if (orsApiKey && (vehicleType === 'hiker' || vehicleType === 'bike')) {
                    try {
                        const orsRoute = await getRouteOpenRouteService(startLat, startLon, destLat, destLon, viaPoints, vehicleType);
                        // Strictly check for unsafe segments - reject if any found
                        const warnings = await checkRouteSafety(orsRoute, vehicleType);
                        if (warnings.length === 0) {
                            return orsRoute; // Perfect route with no unsafe roads
                        }
                        // If there are unsafe segments, try to improve the route
                        console.log(`OpenRouteService route has ${warnings.length} unsafe segments, attempting to avoid them...`);
                        const improvedRoute = await tryAvoidUnsafeRoads(
                            startLat, startLon, destLat, destLon, viaPoints, 
                            orsRoute, vehicleType
                        );
                        if (improvedRoute && improvedRoute.routes) {
                            const improvedWarnings = await checkRouteSafety(improvedRoute, vehicleType);
                            if (improvedWarnings.length < warnings.length) {
                                return improvedRoute;
                            }
                        }
                        // If improvement didn't help, fall through to OSRM alternatives
                        console.log('OpenRouteService route still has unsafe segments, trying OSRM alternatives...');
                    } catch (orsError) {
                        console.warn('OpenRouteService failed, falling back to OSRM:', orsError);
                        // Fall through to OSRM
                    }
                }
                
                // First, get route with alternatives from OSRM
                const routeData = await getRoute(startLat, startLon, destLat, destLon, viaPoints, true);
                
                if (!routeData.routes || routeData.routes.length === 0) {
                    // Fallback to regular route if alternatives not available
                    const fallbackRoute = await getRoute(startLat, startLon, destLat, destLon, viaPoints, false);
                    // Still check and try to improve
                    const warnings = await checkRouteSafety(fallbackRoute, vehicleType);
                    if (warnings.length > 0) {
                        const improvedRoute = await tryAvoidUnsafeRoads(
                            startLat, startLon, destLat, destLon, viaPoints, 
                            fallbackRoute, vehicleType
                        );
                        if (improvedRoute && improvedRoute.routes) {
                            return improvedRoute;
                        }
                    }
                    return fallbackRoute;
                }

                // If only one route or not hiker/bike, check it and try to improve if needed
                if (routeData.routes.length === 1 || (vehicleType !== 'hiker' && vehicleType !== 'bike')) {
                    const singleRoute = {
                        routes: [routeData.routes[0]],
                        code: routeData.code
                    };
                    if (vehicleType === 'hiker' || vehicleType === 'bike') {
                        const warnings = await checkRouteSafety(singleRoute, vehicleType);
                        if (warnings.length > 0) {
                            const improvedRoute = await tryAvoidUnsafeRoads(
                                startLat, startLon, destLat, destLon, viaPoints, 
                                singleRoute, vehicleType
                            );
                            if (improvedRoute && improvedRoute.routes) {
                                return improvedRoute;
                            }
                        }
                    }
                    return singleRoute;
                }

                // Check each route for unsafe segments
                const routeScores = [];
                
                for (let i = 0; i < routeData.routes.length; i++) {
                    const route = {
                        routes: [routeData.routes[i]],
                        code: routeData.code
                    };
                    
                    const warnings = await checkRouteSafety(route, vehicleType);
                    const unsafeCount = warnings.length;
                    const distance = route.routes[0].distance;
                    
                    routeScores.push({
                        index: i,
                        route: route,
                        unsafeCount: unsafeCount,
                        distance: distance,
                        warnings: warnings,
                        score: unsafeCount * 10000 + distance // Heavily penalize unsafe routes
                    });
                }

                // Sort by score (lower is better - fewer unsafe segments, shorter distance)
                routeScores.sort((a, b) => a.score - b.score);
                
                // Return the safest route (lowest score)
                const bestRoute = routeScores[0];
                
                // If the best route has unsafe segments, try to add waypoints to avoid them
                if (bestRoute.unsafeCount > 0) {
                    console.log(`Best OSRM route has ${bestRoute.unsafeCount} unsafe segments, attempting to avoid them...`);
                    // Try to find alternative route by adding intermediate waypoints
                    const improvedRoute = await tryAvoidUnsafeRoads(
                        startLat, startLon, destLat, destLon, viaPoints, 
                        bestRoute.route, vehicleType
                    );
                    if (improvedRoute && improvedRoute.routes) {
                        const improvedWarnings = await checkRouteSafety(improvedRoute, vehicleType);
                        if (improvedWarnings.length < bestRoute.unsafeCount) {
                            return improvedRoute;
                        }
                    }
                }
                
                // Return best route (even if it has some unsafe segments - we'll warn about them)
                return bestRoute.route;
            } catch (error) {
                // If alternatives fail, fall back to regular route
                console.warn('Failed to get route alternatives, using standard route:', error);
                return await getRoute(startLat, startLon, destLat, destLon, viaPoints, false);
            }
        }

        // Find hiking routes (route=hiking, type=route) between waypoints
        async function findHikingRoutes(startLat, startLon, endLat, endLon) {
            try {
                // Search for hiking routes in the area between start and end
                const centerLat = (startLat + endLat) / 2;
                const centerLon = (startLon + endLon) / 2;
                const distance = haversineDistance(startLat, startLon, endLat, endLon);
                const radius = Math.max(5000, distance * 1000 * 0.5); // At least 5km, or half the distance
                
                const query = `
                    [out:json][timeout:25];
                    (
                      relation["route"="hiking"]["type"="route"](around:${radius},${centerLat},${centerLon});
                      way["route"="hiking"]["type"="route"](around:${radius},${centerLat},${centerLon});
                    );
                    out center;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                return data.elements || [];
            } catch (error) {
                console.error('Hiking route search failed:', error);
                return [];
            }
        }

        // Find drinking water points along route
        async function findDrinkingWater(lat, lon, radius = 2000, countryFilter = null) {
            try {
                const query = `
                    [out:json][timeout:25];
                    (
                      node["drinking_water:refill"="yes"](around:${radius},${lat},${lon});
                      node["drinking_water"="yes"](around:${radius},${lat},${lon});
                      node["natural"="spring"](around:${radius},${lat},${lon});
                    );
                    out body;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                const waterPoints = [];

                for (const element of data.elements || []) {
                    if (element.type !== 'node') continue;

                    const isSpring = element.tags?.natural === 'spring';
                    const name = element.tags?.name || 
                                (isSpring ? 'Natural Spring' : 'Drinking Water');
                    
                    waterPoints.push({
                        lat: element.lat,
                        lon: element.lon,
                        name: name,
                        type: isSpring ? 'spring' : 'water',
                        note: isSpring ? 'Drink it at your own risk' : null
                    });
                }

                // Filter by country if countryFilter is provided (use cache, skip delays when batching)
                if (countryFilter) {
                    const filteredWaterPoints = [];
                    for (const water of waterPoints) {
                        const waterCountry = await getCountry(water.lat, water.lon, true); // Skip delay when batching
                        if (waterCountry === countryFilter) {
                            filteredWaterPoints.push(water);
                        }
                    }
                    return filteredWaterPoints;
                }

                return waterPoints;
            } catch (error) {
                console.error('Water point search failed:', error);
                return [];
            }
        }

        // Check road types for safety (hikers and cyclists)
        async function checkRoadTypes(lat, lon, radius = 50) {
            try {
                const query = `
                    [out:json][timeout:25];
                    way(around:${radius},${lat},${lon})["highway"];
                    out body;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                const roadTypes = [];

                for (const element of data.elements || []) {
                    if (element.type !== 'way' || !element.tags) continue;
                    const highway = element.tags.highway;
                    const foot = element.tags.foot;
                    const hiking = element.tags.hiking;
                    
                    if (highway) {
                        roadTypes.push({
                            highway: highway,
                            foot: foot,
                            hiking: hiking,
                            name: element.tags.name || 'Unnamed road'
                        });
                    }
                }

                return roadTypes;
            } catch (error) {
                console.error('Road type check failed:', error);
                return [];
            }
        }

        // Check if road is safe for vehicle type
        function isRoadSafe(roadType, vehicleType) {
            const unsafeRoads = ['motorway', 'trunk', 'primary', 'primary_link', 'motorway_link', 'trunk_link'];
            
            if (unsafeRoads.includes(roadType.highway)) {
                return false;
            }

            if (vehicleType === 'bike') {
                const allowedRoads = ['cycleway', 'path', 'track', 'secondary', 'tertiary', 'unclassified', 'residential', 'living_street'];
                return allowedRoads.includes(roadType.highway);
            } else if (vehicleType === 'hiker') {
                const allowedRoads = ['footway', 'path', 'track', 'steps', 'bridleway'];
                if (allowedRoads.includes(roadType.highway)) {
                    return true;
                }
                // Check for hiking/foot designations
                if (roadType.hiking === 'yes' || roadType.foot === 'designated') {
                    return true;
                }
                // Allow some minor roads if they have foot designation
                if (['secondary', 'tertiary', 'unclassified', 'residential'].includes(roadType.highway)) {
                    return roadType.foot !== 'no';
                }
                return false;
            }

            return true; // Trucks and cars can use all roads
        }

        // Try to avoid unsafe roads by adding intermediate waypoints
        async function tryAvoidUnsafeRoads(startLat, startLon, destLat, destLon, viaPoints, route, vehicleType) {
            try {
                const warnings = await checkRouteSafety(route, vehicleType);
                if (warnings.length === 0) {
                    return route; // No unsafe roads
                }

                console.log(`Attempting to avoid ${warnings.length} unsafe road segments...`);

                // Get coordinates of unsafe segments
                const coordinates = route.routes[0].geometry.coordinates;
                const unsafeSegments = [];
                
                // For each warning, find the closest point on the route
                for (const warning of warnings) {
                    let closestIndex = 0;
                    let minDist = Infinity;
                    
                    for (let i = 0; i < coordinates.length; i++) {
                        const [lon, lat] = coordinates[i];
                        const dist = haversineDistance(lat, lon, warning.lat, warning.lon);
                        if (dist < minDist) {
                            minDist = dist;
                            closestIndex = i;
                        }
                    }
                    
                    unsafeSegments.push({
                        lat: warning.lat,
                        lon: warning.lon,
                        index: closestIndex,
                        roadType: warning.roadType
                    });
                }

                // Try to find alternative routes by adding waypoints that avoid unsafe areas
                // Search for safe roads near unsafe segments - try multiple attempts
                const avoidanceWaypoints = [];
                const processedLocations = new Set();
                
                for (const segment of unsafeSegments) {
                    const locationKey = `${segment.lat.toFixed(3)},${segment.lon.toFixed(3)}`;
                    if (processedLocations.has(locationKey)) continue;
                    processedLocations.add(locationKey);
                    
                    // Search in increasing radius: 1km, 2km, 3km
                    for (const radius of [1000, 2000, 3000]) {
                        const safeRoads = await findSafeRoadsNearby(segment.lat, segment.lon, radius, vehicleType);
                        if (safeRoads.length > 0) {
                            // Use the closest safe road point
                            let closestSafeRoad = safeRoads[0];
                            let minDist = haversineDistance(segment.lat, segment.lon, safeRoads[0].lat, safeRoads[0].lon);
                            for (const road of safeRoads) {
                                const dist = haversineDistance(segment.lat, segment.lon, road.lat, road.lon);
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestSafeRoad = road;
                                }
                            }
                            
                            avoidanceWaypoints.push({
                                lat: closestSafeRoad.lat,
                                lon: closestSafeRoad.lon,
                                name: `Avoid ${segment.roadType}`
                            });
                            break; // Found a safe road, move to next segment
                        }
                        await delay(200); // Rate limiting
                    }
                }

                // If we found avoidance waypoints, try recalculating the route
                if (avoidanceWaypoints.length > 0) {
                    console.log(`Adding ${avoidanceWaypoints.length} waypoints to avoid unsafe roads...`);
                    
                    // Build ordered waypoint list: preserve original via points order, insert avoidance waypoints
                    // based on their position along the route
                    const routeCoordinates = route.routes[0].geometry.coordinates;
                    
                    // Start with original via points in their original order
                    const allViaPoints = [...viaPoints];
                    
                    // For each avoidance waypoint, find where it should be inserted
                    // based on its position relative to the route and existing via points
                    for (const avoidancePoint of avoidanceWaypoints) {
                        // Find the closest point on the route to this avoidance waypoint
                        let closestRouteIndex = 0;
                        let minDist = Infinity;
                        for (let i = 0; i < routeCoordinates.length; i++) {
                            const [lon, lat] = routeCoordinates[i];
                            const dist = haversineDistance(lat, lon, avoidancePoint.lat, avoidancePoint.lon);
                            if (dist < minDist) {
                                minDist = dist;
                                closestRouteIndex = i;
                            }
                        }
                        
                        // Find which original via point this avoidance point is closest to
                        // Insert it after that via point
                        let insertIndex = allViaPoints.length;
                        for (let i = 0; i < viaPoints.length; i++) {
                            const viaPoint = viaPoints[i];
                            // Find via point's position on route
                            let viaRouteIndex = 0;
                            let viaMinDist = Infinity;
                            for (let j = 0; j < routeCoordinates.length; j++) {
                                const [lon, lat] = routeCoordinates[j];
                                const dist = haversineDistance(lat, lon, viaPoint.lat, viaPoint.lon);
                                if (dist < viaMinDist) {
                                    viaMinDist = dist;
                                    viaRouteIndex = j;
                                }
                            }
                            
                            // If avoidance point is after this via point on the route, insert after it
                            if (closestRouteIndex > viaRouteIndex) {
                                insertIndex = i + 1;
                            }
                        }
                        
                        // Insert the avoidance waypoint at the calculated position
                        allViaPoints.splice(insertIndex, 0, avoidancePoint);
                    }
                    
                    // Try with OpenRouteService first if available
                    let newRoute = null;
                    if (orsApiKey && (vehicleType === 'hiker' || vehicleType === 'bike')) {
                        try {
                            newRoute = await getRouteOpenRouteService(startLat, startLon, destLat, destLon, allViaPoints, vehicleType);
                        } catch (e) {
                            console.warn('OpenRouteService failed with waypoints, trying OSRM:', e);
                        }
                    }
                    
                    if (!newRoute) {
                        newRoute = await getRoute(startLat, startLon, destLat, destLon, allViaPoints, false);
                    }
                    
                    const newWarnings = await checkRouteSafety(newRoute, vehicleType);
                    
                    // If new route has fewer unsafe segments, use it
                    if (newWarnings.length < warnings.length) {
                        console.log(`Improved route: reduced unsafe segments from ${warnings.length} to ${newWarnings.length}`);
                        return newRoute;
                    } else {
                        console.log(`Route improvement didn't help: still ${newWarnings.length} unsafe segments`);
                    }
                } else {
                    console.log('No safe roads found near unsafe segments');
                }
                
                return null; // Couldn't improve
            } catch (error) {
                console.error('Failed to avoid unsafe roads:', error);
                return null;
            }
        }

        // Find safe roads nearby an unsafe location
        async function findSafeRoadsNearby(lat, lon, radius, vehicleType) {
            try {
                const query = `
                    [out:json][timeout:25];
                    way(around:${radius},${lat},${lon})["highway"];
                    out center;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                const safeRoads = [];

                for (const element of data.elements || []) {
                    if (element.type !== 'way' || !element.tags) continue;
                    
                    const roadType = {
                        highway: element.tags.highway,
                        foot: element.tags.foot,
                        hiking: element.tags.hiking,
                        name: element.tags.name || 'Unnamed road'
                    };
                    
                    if (isRoadSafe(roadType, vehicleType)) {
                        if (element.center) {
                            safeRoads.push({
                                lat: element.center.lat,
                                lon: element.center.lon,
                                name: roadType.name
                            });
                        }
                    }
                }

                return safeRoads;
            } catch (error) {
                console.error('Failed to find safe roads:', error);
                return [];
            }
        }

        // Check route for unsafe road segments (faster version for route comparison)
        async function checkRouteSafety(route, vehicleType) {
            if (vehicleType !== 'hiker' && vehicleType !== 'bike') {
                return []; // Only check for hikers and cyclists
            }

            const warnings = [];
            const coordinates = route.routes[0].geometry.coordinates;
            
            // Sample points along the route more efficiently for route comparison
            // Use fewer samples for faster comparison, more for final detailed check
            const sampleInterval = Math.max(1, Math.floor(coordinates.length / 15));
            const checkedPoints = new Set();

            for (let i = 0; i < coordinates.length; i += sampleInterval) {
                const [lon, lat] = coordinates[i];
                const pointKey = `${lat.toFixed(3)},${lon.toFixed(3)}`;
                
                // Avoid checking the same point twice
                if (checkedPoints.has(pointKey)) continue;
                checkedPoints.add(pointKey);

                const roadTypes = await checkRoadTypes(lat, lon, 50);
                
                for (const roadType of roadTypes) {
                    if (!isRoadSafe(roadType, vehicleType)) {
                        // Check if we already have a warning for this location
                        const existingWarning = warnings.find(w => 
                            Math.abs(w.lat - lat) < 0.002 && 
                            Math.abs(w.lon - lon) < 0.002 &&
                            w.roadType === roadType.highway
                        );
                        
                        if (!existingWarning) {
                            warnings.push({
                                lat: lat,
                                lon: lon,
                                roadType: roadType.highway,
                                roadName: roadType.name,
                                message: `Unsafe road type: ${roadType.highway}`
                            });
                        }
                    }
                }

                await delay(150); // Rate limiting (faster for comparison)
            }

            return warnings;
        }

        // Check road for axle load restrictions (trucks only)
        async function checkAxleLoadRestrictions(lat, lon) {
            try {
                const query = `
                    [out:json][timeout:25];
                    way(around:50,${lat},${lon})["highway"];
                    out body;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                const warnings = [];

                for (const element of data.elements || []) {
                    if (element.type !== 'way' || !element.tags) continue;

                    const tags = element.tags;
                    const maxAxleLoad = parseFloat(tags['maxaxleload']) || parseFloat(tags['maxaxleload:hgv']);
                    const maxWeight = parseFloat(tags['maxweight']) || parseFloat(tags['maxweight:hgv']);
                    const vehicleRestriction = tags['motor_vehicle'] === 'no' || tags['hgv'] === 'no' || tags['motorcar'] === 'no';

                    if (vehicleRestriction) {
                        warnings.push({
                            lat: lat,
                            lon: lon,
                            type: 'restriction',
                            message: `Road prohibits trucks/HGVs`,
                            highway: tags.highway || 'unknown'
                        });
                    } else if (maxAxleLoad && truckSpecs.axleLoad > maxAxleLoad) {
                        warnings.push({
                            lat: lat,
                            lon: lon,
                            type: 'axleload',
                            message: `Max axle load: ${maxAxleLoad} tonnes (your truck: ${truckSpecs.axleLoad} tonnes)`,
                            highway: tags.highway || 'unknown',
                            maxAxleLoad: maxAxleLoad
                        });
                    } else if (maxWeight && truckSpecs.totalWeight > maxWeight) {
                        warnings.push({
                            lat: lat,
                            lon: lon,
                            type: 'weight',
                            message: `Max weight: ${maxWeight} tonnes (your truck: ${truckSpecs.totalWeight} tonnes)`,
                            highway: tags.highway || 'unknown',
                            maxWeight: maxWeight
                        });
                    }
                }

                return warnings;
            } catch (error) {
                console.error('Axle load check failed:', error);
                return [];
            }
        }

        // Find parking spots for trucks/cars
        async function findParkingSpots(lat, lon, radius = 3000, countryFilter = null) {
            try {
                // Query for rest areas and intersection nodes
                // Rest areas: highway=rest_area or amenity=rest_area
                // Intersections: nodes that are part of multiple highway ways
                const query = `
                    [out:json][timeout:25];
                    (
                      // Rest areas
                      way["highway"="rest_area"](around:${radius},${lat},${lon});
                      node["highway"="rest_area"](around:${radius},${lat},${lon});
                      node["amenity"="rest_area"](around:${radius},${lat},${lon});
                      
                      // Get all highway ways in area to find intersections
                      way["highway"](around:${radius},${lat},${lon});
                    );
                    (._;>;);
                    out center;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                const spots = [];
                const nodeWayCount = new Map(); // Track how many ways each node belongs to
                const restAreaNodes = new Set(); // Track rest area nodes
                const restAreaWays = []; // Track rest area ways
                const nodeCoords = new Map(); // Store node coordinates

                // First pass: collect all data
                for (const element of data.elements || []) {
                    if (element.type === 'node') {
                        // Store coordinates
                        if (element.lat && element.lon) {
                            nodeCoords.set(element.id, { lat: element.lat, lon: element.lon });
                        }
                        
                        // Check if it's a rest area
                        if (element.tags?.highway === 'rest_area' || element.tags?.amenity === 'rest_area') {
                            restAreaNodes.add(element.id);
                            spots.push({
                                lat: element.lat,
                                lon: element.lon,
                                type: 'rest_area',
                                name: element.tags?.name || 'Rest Area'
                            });
                        }
                    } else if (element.type === 'way') {
                        // Check if it's a rest area way
                        if (element.tags?.highway === 'rest_area') {
                            restAreaWays.push(element);
                        }
                        
                        // Count nodes in this way for intersection detection
                        if (element.nodes && Array.isArray(element.nodes)) {
                            for (const nodeId of element.nodes) {
                                nodeWayCount.set(nodeId, (nodeWayCount.get(nodeId) || 0) + 1);
                            }
                        }
                    }
                }

                // Add rest area way centers
                for (const way of restAreaWays) {
                    if (way.center) {
                        spots.push({
                            lat: way.center.lat,
                            lon: way.center.lon,
                            type: 'rest_area',
                            name: way.tags?.name || 'Rest Area'
                        });
                    }
                }

                // Find intersection nodes (nodes that belong to 2+ ways)
                for (const [nodeId, count] of nodeWayCount.entries()) {
                    if (count >= 2 && !restAreaNodes.has(nodeId)) {
                        const coords = nodeCoords.get(nodeId);
                        if (coords) {
                            spots.push({
                                lat: coords.lat,
                                lon: coords.lon,
                                type: 'intersection',
                                name: `Intersection (${count} roads)`
                            });
                        }
                    }
                }

                // Separate rest areas and intersections
                const restAreas = spots.filter(s => s.type === 'rest_area');
                const intersections = spots.filter(s => s.type === 'intersection');

                // Limit intersections to top 5 for building checks (optimization)
                const topIntersections = intersections.slice(0, 5);

                // Filter out spots with buildings within 150m (only for intersections, rest areas are always valid)
                // Also filter by country if countryFilter is provided
                const filteredSpots = [];
                
                // Process rest areas first (always valid, but check country)
                for (const spot of restAreas) {
                    if (countryFilter) {
                        const spotCountry = await getCountry(spot.lat, spot.lon, true); // Skip delay when batching
                        if (spotCountry !== countryFilter) {
                            continue;
                        }
                    }
                    filteredSpots.push(spot);
                }

                // Process top intersections with building checks (limit to 5 for performance)
                const intersectionChecks = topIntersections.map(async (spot) => {
                    // Check country if filter is provided
                    if (countryFilter) {
                        const spotCountry = await getCountry(spot.lat, spot.lon, true); // Skip delay when batching
                        if (spotCountry !== countryFilter) {
                            return null;
                        }
                    }
                    
                    // Check for nearby buildings
                    const hasBuildings = await checkForBuildings(spot.lat, spot.lon);
                    if (!hasBuildings) {
                        return spot;
                    }
                    return null;
                });

                // Wait for all building checks in parallel
                const validIntersections = (await Promise.all(intersectionChecks)).filter(s => s !== null);
                filteredSpots.push(...validIntersections);

                return filteredSpots;
            } catch (error) {
                console.error('Parking spot search failed:', error);
                return [];
            }
        }

        // Find rest spots for hikers and cyclists (huts and shelters)
        async function findHikerRestSpots(lat, lon, radius = 5000, countryFilter = null) {
            try {
                const query = `
                    [out:json][timeout:25];
                    (
                      node["tourism"="wilderness_hut"](around:${radius},${lat},${lon});
                      node["tourism"="alpine_hut"](around:${radius},${lat},${lon});
                      node["amenity"="shelter"]["shelter_type"="basic_hut"]["locked"="no"](around:${radius},${lat},${lon});
                      node["amenity"="shelter"](around:${radius},${lat},${lon});
                      node["tourism"="camp_site"](around:${radius},${lat},${lon});
                      node["leisure"="picnic_table"](around:${radius},${lat},${lon});
                    );
                    out body;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                const spots = [];

                for (const element of data.elements || []) {
                    if (element.type !== 'node') continue;

                    const tags = element.tags || {};
                    let type = tags.tourism || tags.amenity || tags.leisure || 'rest_area';
                    let name = tags.name || 'Unnamed spot';
                    
                    // Categorize the shelter type
                    if (tags.tourism === 'wilderness_hut') {
                        type = 'wilderness_hut';
                        name = tags.name || 'Wilderness Hut';
                    } else if (tags.tourism === 'alpine_hut') {
                        type = 'alpine_hut';
                        name = tags.name || 'Alpine Hut';
                    } else if (tags.shelter_type === 'basic_hut' && tags.locked === 'no') {
                        type = 'basic_hut';
                        name = tags.name || 'Basic Hut (Unlocked)';
                    } else if (tags.amenity === 'shelter') {
                        type = 'shelter';
                        name = tags.name || 'Shelter';
                    }

                    spots.push({
                        lat: element.lat,
                        lon: element.lon,
                        type: type,
                        name: name,
                        locked: tags.locked,
                        shelter_type: tags.shelter_type
                    });
                }

                // Filter by country if countryFilter is provided (use cache, skip delays when batching)
                if (countryFilter) {
                    const filteredSpots = [];
                    for (const spot of spots) {
                        const spotCountry = await getCountry(spot.lat, spot.lon, true); // Skip delay when batching
                        if (spotCountry === countryFilter) {
                            filteredSpots.push(spot);
                        }
                    }
                    return filteredSpots;
                }

                return spots;
            } catch (error) {
                console.error('Hiker rest spot search failed:', error);
                return [];
            }
        }

        // Building check cache to avoid redundant API calls
        const buildingCheckCache = new Map();
        const BUILDING_CACHE_RADIUS = 0.001; // ~100m radius for cache hits

        // Helper function to generate cache key for building checks
        function getBuildingCacheKey(lat, lon) {
            const roundedLat = Math.round(lat / BUILDING_CACHE_RADIUS) * BUILDING_CACHE_RADIUS;
            const roundedLon = Math.round(lon / BUILDING_CACHE_RADIUS) * BUILDING_CACHE_RADIUS;
            return `${roundedLat.toFixed(5)},${roundedLon.toFixed(5)}`;
        }

        // Check for buildings/structures within 150m (with caching)
        async function checkForBuildings(lat, lon) {
            // Check cache first
            const cacheKey = getBuildingCacheKey(lat, lon);
            if (buildingCheckCache.has(cacheKey)) {
                return buildingCheckCache.get(cacheKey);
            }

            try {
                const query = `
                    [out:json][timeout:25];
                    (
                      way["building"](around:150,${lat},${lon});
                      node["man_made"](around:150,${lat},${lon});
                    );
                    out count;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                const data = await response.json();
                const hasBuildings = (data.elements?.length || 0) > 0;
                
                // Cache the result
                buildingCheckCache.set(cacheKey, hasBuildings);
                return hasBuildings;
            } catch (error) {
                console.error('Building check failed:', error);
                return false;
            }
        }

        // Calculate rest stops along route
        function calculateRestStops(route, departureTime) {
            const restStops = [];
            const coordinates = route.routes[0].geometry.coordinates;
            const distance = route.routes[0].distance / 1000; // km
            const duration = route.routes[0].duration; // seconds

            let currentTime = new Date(departureTime);

            if (vehicleType === 'hiker') {
                // Hiker: 40 km per day suggested maximum
                // Optimized: Use route distance directly and sample coordinates
                const totalDistance = route.routes[0].distance; // meters
                const sampleInterval = Math.max(1, Math.floor(coordinates.length / Math.max(100, Math.floor(totalDistance / 1000)))); // Sample every Nth point based on route length
                
                let accumulatedDistance = 0; // meters
                let dayCount = 0;
                let restCount = 0;
                let altRestCount = 0;
                let lastProcessedIndex = 0;

                // Helper to find coordinate at specific distance
                function findCoordinateAtDistance(targetDist) {
                    let accDist = 0;
                    for (let i = 0; i < coordinates.length - 1; i++) {
                        const [lon1, lat1] = coordinates[i];
                        const [lon2, lat2] = coordinates[i + 1];
                        const segDist = haversineDistance(lat1, lon1, lat2, lon2) * 1000;
                        
                        if (accDist + segDist >= targetDist) {
                            const ratio = (targetDist - accDist) / segDist;
                            return {
                                lat: lat1 + (lat2 - lat1) * ratio,
                                lon: lon1 + (lon2 - lon1) * ratio,
                                distance: targetDist / 1000,
                                index: i
                            };
                        }
                        accDist += segDist;
                    }
                    const last = coordinates[coordinates.length - 1];
                    return {
                        lat: last[1],
                        lon: last[0],
                        distance: totalDistance / 1000,
                        index: coordinates.length - 1
                    };
                }

                // Sample coordinates instead of checking every pair
                for (let i = 0; i < coordinates.length - 1; i += sampleInterval) {
                    const [lon1, lat1] = coordinates[i];
                    const [lon2, lat2] = coordinates[Math.min(i + sampleInterval, coordinates.length - 1)];
                    const segmentDistance = haversineDistance(lat1, lon1, lat2, lon2) * 1000;
                    accumulatedDistance += segmentDistance;

                    // Daily segment: 40 km per day
                    if (accumulatedDistance >= (dayCount + 1) * 40000) {
                        dayCount++;
                        const coord = findCoordinateAtDistance((dayCount) * 40000);
                        restStops.push({
                            type: 'daily-segment',
                            lat: coord.lat,
                            lon: coord.lon,
                            distance: coord.distance,
                            day: dayCount,
                            index: coord.index
                        });
                    }

                    // Check for main rest (11.295 km)
                    if (accumulatedDistance >= (restCount + 1) * 11295) {
                        restCount++;
                        const coord = findCoordinateAtDistance((restCount) * 11295);
                        restStops.push({
                            type: 'hiker-rest',
                            lat: coord.lat,
                            lon: coord.lon,
                            distance: coord.distance,
                            index: coord.index
                        });
                    }

                    // Check for alternative rest (2.2752 km)
                    if (accumulatedDistance >= (altRestCount + 1) * 2275.2) {
                        altRestCount++;
                        const coord = findCoordinateAtDistance((altRestCount) * 2275.2);
                        // Only add if not too close to main rest
                        const lastMainRest = restStops.filter(s => s.type === 'hiker-rest').pop();
                        if (!lastMainRest || (coord.distance * 1000 - lastMainRest.distance * 1000) > 1000) {
                            restStops.push({
                                type: 'hiker-rest-alt',
                                lat: coord.lat,
                                lon: coord.lon,
                                distance: coord.distance,
                                index: coord.index
                            });
                        }
                    }
                }
            } else if (vehicleType === 'bike') {
                // Cycling: 70 km per day, 4 segments of 17 km each
                // Optimized: Use route distance directly and sample coordinates
                const totalDistance = route.routes[0].distance; // meters
                const sampleInterval = Math.max(1, Math.floor(coordinates.length / Math.max(100, Math.floor(totalDistance / 1000)))); // Sample every Nth point
                
                let accumulatedDistance = 0; // meters
                let dayCount = 0;
                let segmentCount = 0;

                // Helper to find coordinate at specific distance
                function findCoordinateAtDistance(targetDist) {
                    let accDist = 0;
                    for (let i = 0; i < coordinates.length - 1; i++) {
                        const [lon1, lat1] = coordinates[i];
                        const [lon2, lat2] = coordinates[i + 1];
                        const segDist = haversineDistance(lat1, lon1, lat2, lon2) * 1000;
                        
                        if (accDist + segDist >= targetDist) {
                            const ratio = (targetDist - accDist) / segDist;
                            return {
                                lat: lat1 + (lat2 - lat1) * ratio,
                                lon: lon1 + (lon2 - lon1) * ratio,
                                distance: targetDist / 1000,
                                index: i
                            };
                        }
                        accDist += segDist;
                    }
                    const last = coordinates[coordinates.length - 1];
                    return {
                        lat: last[1],
                        lon: last[0],
                        distance: totalDistance / 1000,
                        index: coordinates.length - 1
                    };
                }

                // Sample coordinates instead of checking every pair
                for (let i = 0; i < coordinates.length - 1; i += sampleInterval) {
                    const [lon1, lat1] = coordinates[i];
                    const [lon2, lat2] = coordinates[Math.min(i + sampleInterval, coordinates.length - 1)];
                    const segmentDistance = haversineDistance(lat1, lon1, lat2, lon2) * 1000;
                    accumulatedDistance += segmentDistance;

                    // Daily segment: 70 km per day
                    if (accumulatedDistance >= (dayCount + 1) * 70000) {
                        dayCount++;
                        const coord = findCoordinateAtDistance((dayCount) * 70000);
                        restStops.push({
                            type: 'daily-segment',
                            lat: coord.lat,
                            lon: coord.lon,
                            distance: coord.distance,
                            day: dayCount,
                            index: coord.index
                        });
                    }

                    // Segment breaks: 17 km per segment (4 segments per day)
                    if (accumulatedDistance >= (segmentCount + 1) * 17000) {
                        segmentCount++;
                        const coord = findCoordinateAtDistance((segmentCount) * 17000);
                        restStops.push({
                            type: 'segment-break',
                            lat: coord.lat,
                            lon: coord.lon,
                            distance: coord.distance,
                            segment: segmentCount,
                            index: coord.index
                        });
                    }
                }
            } else {
                // Truck/Car rest rules (EU Regulation EC 561/2006)
                // Use route distance/time directly instead of iterating all points
                const totalDistance = route.routes[0].distance / 1000; // km
                const totalDuration = route.routes[0].duration / 3600; // hours
                const avgSpeed = totalDistance / totalDuration; // km/h (actual route speed)

                const breakInterval = 4.5; // hours
                const breakTolerance = 20 / 60; // 20 minutes tolerance (¬±0.33 hours)
                const dailyRestInterval = 9; // hours
                const dailyRestTolerance = 20 / 60; // 20 minutes tolerance (¬±0.33 hours)
                const weeklyRestDays = 6;

                let breakCount = 0;
                let dailyRestCount = 0;
                let daysDriving = 0;
                let weeklyRestCount = 0;

                // Helper function to find coordinate at specific distance along route
                function findCoordinateAtDistance(targetDistance) {
                    let accumulatedDist = 0;
                    for (let i = 0; i < coordinates.length - 1; i++) {
                        const [lon1, lat1] = coordinates[i];
                        const [lon2, lat2] = coordinates[i + 1];
                        const segmentDist = haversineDistance(lat1, lon1, lat2, lon2);
                        
                        if (accumulatedDist + segmentDist >= targetDistance) {
                            // Interpolate between points
                            const ratio = (targetDistance - accumulatedDist) / segmentDist;
                            return {
                                lat: lat1 + (lat2 - lat1) * ratio,
                                lon: lon1 + (lon2 - lon1) * ratio,
                                distance: targetDistance,
                                index: i
                            };
                        }
                        accumulatedDist += segmentDist;
                    }
                    // If target distance exceeds route, return last point
                    const last = coordinates[coordinates.length - 1];
                    return {
                        lat: last[1],
                        lon: last[0],
                        distance: totalDistance,
                        index: coordinates.length - 1
                    };
                }

                // Calculate breaks (every 4.5 hours with ¬±20 min tolerance)
                // Tolerance allows breaks to be taken 20 minutes before or after the 4.5h mark
                let nextBreakTime = breakInterval;
                while (nextBreakTime - breakTolerance <= totalDuration) {
                    // Calculate break time (can be within tolerance window)
                    // Use the exact interval time, tolerance is regulatory allowance
                    const breakTime = Math.min(nextBreakTime, totalDuration);
                    const breakDistance = (breakTime / totalDuration) * totalDistance;
                    const coord = findCoordinateAtDistance(breakDistance);
                    
                    restStops.push({
                        type: 'break',
                        lat: coord.lat,
                        lon: coord.lon,
                        distance: coord.distance,
                        time: new Date(currentTime.getTime() + breakTime * 3600000),
                        duration: 45, // minutes
                        index: coord.index,
                        tolerance: '¬±20 minutes'
                    });
                    
                    breakCount++;
                    // Next break: add interval
                    // If next break would overlap with daily rest, skip to daily rest instead
                    const nextBreakCandidate = nextBreakTime + breakInterval;
                    const nextDailyRestTime = (dailyRestCount + 1) * dailyRestInterval;
                    if (nextBreakCandidate >= nextDailyRestTime - dailyRestTolerance) {
                        // Skip break if daily rest is coming soon (within tolerance)
                        nextBreakTime = nextDailyRestTime;
                    } else {
                        nextBreakTime = nextBreakCandidate;
                    }
                }

                // Calculate daily rest (every 9 hours with ¬±20 min tolerance)
                // Tolerance allows daily rest to be taken 20 minutes before or after the 9h mark
                let nextDailyRestTime = dailyRestInterval;
                while (nextDailyRestTime - dailyRestTolerance <= totalDuration) {
                    // Calculate daily rest time (can be within tolerance window)
                    const dailyRestTime = Math.min(nextDailyRestTime, totalDuration);
                    const dailyRestDistance = (dailyRestTime / totalDuration) * totalDistance;
                    const coord = findCoordinateAtDistance(dailyRestDistance);
                    
                    daysDriving++;
                    restStops.push({
                        type: 'daily',
                        lat: coord.lat,
                        lon: coord.lon,
                        distance: coord.distance,
                        time: new Date(currentTime.getTime() + dailyRestTime * 3600000),
                        duration: 11, // hours
                        index: coord.index,
                        tolerance: '¬±20 minutes'
                    });
                    
                    dailyRestCount++;
                    
                    // Check for weekly rest (every 6 days)
                    if (daysDriving >= weeklyRestDays && weeklyRestCount === 0) {
                        weeklyRestCount++;
                        restStops.push({
                            type: 'weekly',
                            lat: coord.lat,
                            lon: coord.lon,
                            distance: coord.distance,
                            time: new Date(currentTime.getTime() + dailyRestTime * 3600000),
                            duration: 45, // hours
                            index: coord.index
                        });
                        daysDriving = 0;
                    }
                    
                    nextDailyRestTime += dailyRestInterval;
                }

                // Sort rest stops by distance to maintain order
                restStops.sort((a, b) => a.distance - b.distance);
            }

            return restStops;
        }

        // Clear map
        function clearMap() {
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }
            // Clear start/end/via markers
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
            }
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
            }
            viaMarkers.forEach(marker => map.removeLayer(marker));
            viaMarkers = [];
            addedWaterPoints = []; // Reset water points tracking
            addedHuts = []; // Reset huts tracking
        }

        // Filter water points by minimum distance (4 km)
        function filterWaterPointsByDistance(waterPoints, minDistanceKm = 4) {
            const filtered = [];
            
            for (const water of waterPoints) {
                let tooClose = false;
                
                // Check distance to all already added water points
                for (const existing of addedWaterPoints) {
                    const distance = haversineDistance(water.lat, water.lon, existing.lat, existing.lon);
                    if (distance < minDistanceKm) {
                        tooClose = true;
                        break;
                    }
                }
                
                // If not too close, add it
                if (!tooClose) {
                    filtered.push(water);
                    addedWaterPoints.push(water); // Track it
                }
            }
            
            return filtered;
        }

        // Filter huts/shelters by minimum distance (1300 meters)
        function filterHutsByDistance(huts, minDistanceMeters = 1.3) {
            const filtered = [];
            
            for (const hut of huts) {
                let tooClose = false;
                
                // Check distance to all already added huts
                for (const existing of addedHuts) {
                    const distance = haversineDistance(hut.lat, hut.lon, existing.lat, existing.lon);
                    if (distance < minDistanceMeters) {
                        tooClose = true;
                        break;
                    }
                }
                
                // If not too close, add it
                if (!tooClose) {
                    filtered.push(hut);
                    addedHuts.push(hut); // Track it
                }
            }
            
            return filtered;
        }

        // Add marker to map
        function addMarker(lat, lon, type, popupContent) {
            let color;
            switch (type) {
                case 'break':
                    color = '#f39c12';
                    break;
                case 'daily':
                    color = '#e74c3c';
                    break;
                case 'weekly':
                    color = '#9b59b6';
                    break;
                case 'parking':
                    color = '#27ae60';
                    break;
                case 'hiker-rest':
                    color = '#3498db';
                    break;
                case 'hiker-rest-alt':
                    color = '#5dade2';
                    break;
                case 'axle-warning':
                    color = '#f1c40f';
                    break;
                case 'water':
                    color = '#3498db';
                    break;
                case 'daily-segment':
                    color = '#16a085';
                    break;
                case 'segment-break':
                    color = '#f39c12';
                    break;
                case 'start':
                    color = '#2ecc71';
                    break;
                case 'end':
                    color = '#e74c3c';
                    break;
                default:
                    color = '#3498db';
            }

            const marker = L.circleMarker([lat, lon], {
                radius: 8,
                fillColor: color,
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);

            marker.bindPopup(popupContent);
            markers.push(marker);
        }

        // Update route summary
        function updateRouteSummary(route, startName, destName) {
            const distance = (route.routes[0].distance / 1000).toFixed(1);
            const duration = route.routes[0].duration;
            const hours = Math.floor(duration / 3600);
            const minutes = Math.floor((duration % 3600) / 60);

            document.getElementById('routeSummary').innerHTML = `
                <div class="route-summary">
                    <div class="route-summary-item">
                        <span><strong>Vehicle:</strong></span>
                        <span>${vehicleType.charAt(0).toUpperCase() + vehicleType.slice(1)}</span>
                    </div>
                    <div class="route-summary-item">
                        <span><strong>From:</strong></span>
                        <span>${startName}</span>
                    </div>
                    <div class="route-summary-item">
                        <span><strong>To:</strong></span>
                        <span>${destName}</span>
                    </div>
                    <div class="route-summary-item">
                        <span><strong>Distance:</strong></span>
                        <span>${distance} km</span>
                    </div>
                    <div class="route-summary-item">
                        <span><strong>Duration:</strong></span>
                        <span>${hours}h ${minutes}m</span>
                    </div>
                </div>
            `;
        }

        // Update rest stops list
        function updateRestStopsList(restStops) {
            const list = document.getElementById('restStopsList');
            if (restStops.length === 0) {
                list.innerHTML = '<p style="color: #999;">No rest stops needed for this route</p>';
                return;
            }

            list.innerHTML = restStops.map((stop, index) => {
                let typeLabel, timeStr = '';
                
                if (vehicleType === 'hiker') {
                    if (stop.type === 'daily-segment') {
                        typeLabel = `Day ${stop.day} End (40 km suggested)`;
                        timeStr = `Distance: ${stop.distance.toFixed(2)} km`;
                    } else if (stop.type === 'hiker-rest') {
                        typeLabel = 'Rest (11.295 km)';
                        timeStr = `Distance: ${stop.distance.toFixed(2)} km`;
                    } else {
                        typeLabel = 'Alternative Rest (2.275 km)';
                        timeStr = `Distance: ${stop.distance.toFixed(2)} km`;
                    }
                } else if (vehicleType === 'bike') {
                    if (stop.type === 'daily-segment') {
                        typeLabel = `Day ${stop.day} End (70 km suggested)`;
                        timeStr = `Distance: ${stop.distance.toFixed(2)} km`;
                    } else if (stop.type === 'segment-break') {
                        typeLabel = `Segment ${stop.segment} Break (17 km)`;
                        timeStr = `Distance: ${stop.distance.toFixed(2)} km`;
                    } else {
                        typeLabel = stop.type;
                        timeStr = `Distance: ${stop.distance.toFixed(2)} km`;
                    }
                } else {
                    typeLabel = {
                        'break': '45-min Break',
                        'daily': 'Daily Rest (11h)',
                        'weekly': 'Weekly Rest (45h)'
                    }[stop.type] || stop.type;
                    timeStr = `Time: ${stop.time.toLocaleString()}<br>Distance: ${stop.distance.toFixed(1)} km`;
                }

                return `
                    <div class="rest-stop-item ${stop.type}" onclick="map.setView([${stop.lat}, ${stop.lon}], 12)">
                        <div class="rest-stop-title">${typeLabel}</div>
                        <div class="rest-stop-details">
                            ${timeStr}<br>
                            Location: ${stop.lat.toFixed(4)}, ${stop.lon.toFixed(4)}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Update axle warnings
        function updateAxleWarnings(warnings) {
            const warningsDiv = document.getElementById('axleWarnings');
            const section = document.getElementById('axleWarningsSection');

            if (warnings.length === 0) {
                warningsDiv.innerHTML = '<p style="color: #999;">No axle load restrictions found</p>';
                section.style.display = vehicleType === 'truck' ? 'block' : 'none';
                return;
            }

            warningsDiv.innerHTML = warnings.map(warning => `
                <div class="axle-warning-item">
                    <div class="axle-warning-title">Warning</div>
                    <div class="axle-warning-text">
                        ${warning.message}<br>
                        Road: ${warning.highway}<br>
                        Location: ${warning.lat.toFixed(4)}, ${warning.lon.toFixed(4)}
                    </div>
                </div>
            `).join('');

            section.style.display = 'block';
        }

        // Update safety warnings
        function updateSafetyWarnings(warnings) {
            const warningsDiv = document.getElementById('safetyWarnings');
            const section = document.getElementById('safetyWarningsSection');

            if (warnings.length === 0) {
                warningsDiv.innerHTML = '<p style="color: #28a745;">‚úì No unsafe roads detected. Route is safe!</p>';
                section.style.display = (vehicleType === 'hiker' || vehicleType === 'bike') ? 'block' : 'none';
                return;
            }

            const unsafeRoadTypes = [...new Set(warnings.map(w => w.roadType))];
            
            warningsDiv.innerHTML = `
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 4px; padding: 10px; margin-bottom: 10px;">
                    <strong style="color: #856404;">‚ö†Ô∏è Route contains ${warnings.length} unsafe road segment${warnings.length > 1 ? 's' : ''}</strong>
                    <p style="margin: 5px 0; color: #856404; font-size: 0.9em;">
                        The route includes forbidden road types: <strong>${unsafeRoadTypes.join(', ')}</strong>. 
                        These roads are unsafe for ${vehicleType === 'hiker' ? 'hikers' : 'cyclists'}.
                    </p>
                    <p style="margin: 5px 0; color: #856404; font-size: 0.85em;">
                        <strong>Recommendation:</strong> Add via points around these areas to force the route to use safer roads, 
                        or manually adjust your route to avoid these segments.
                    </p>
                </div>
                ${warnings.map((warning, index) => `
                    <div class="axle-warning-item" style="margin-bottom: 10px;">
                        <div class="axle-warning-title">Warning ${index + 1}: ${warning.roadType}</div>
                        <div class="axle-warning-text">
                            <strong>Road:</strong> ${warning.roadName || 'Unnamed road'}<br>
                            <strong>Location:</strong> ${warning.lat.toFixed(4)}, ${warning.lon.toFixed(4)}<br>
                            <button onclick="map.setView([${warning.lat}, ${warning.lon}], 14)" 
                                    style="margin-top: 5px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 0.85em;">
                                View on Map
                            </button>
                        </div>
                    </div>
                `).join('')}
            `;

            section.style.display = 'block';
            
            // Log warning for debugging
            console.warn(`Route contains ${warnings.length} unsafe road segments: ${unsafeRoadTypes.join(', ')}`);
        }

        // Update country warnings
        function updateCountryWarnings(countries) {
            const warningsDiv = document.getElementById('countryWarnings');
            const section = document.getElementById('countryWarningsSection');

            if (vehicleType === 'hiker' || vehicleType === 'bike') {
                section.style.display = 'none';
                return;
            }

            const uniqueCountries = [...new Set(countries)];

            warningsDiv.innerHTML = uniqueCountries.map(country => {
                const rule = COUNTRY_RULES[country];
                if (!rule) return '';

                return `
                    <div class="country-warning ${rule.class}">
                        <div class="country-warning-title">${country}</div>
                        <div class="country-warning-text">${rule.rules}</div>
                    </div>
                `;
            }).join('') || '<p style="color: #999;">No Nordic countries in route</p>';

            section.style.display = 'block';
        }

        // Cancel ongoing calculation and reset UI
        function cancelCalculation() {
            if (isCalculating) {
                console.log('Cancelling ongoing calculation...');
                calculationId++; // Increment to invalidate ongoing calculation
                isCalculating = false;
                const calculateBtn = document.getElementById('calculateBtn');
                const loadingDiv = document.getElementById('loading');
                calculateBtn.disabled = false;
                // Don't hide loading div - let new calculation handle it
            }
        }

        // Main route calculation function
        async function calculateRoute() {
            // If already calculating, cancel the previous calculation
            if (isCalculating) {
                console.log('Cancelling previous calculation and starting new one...');
                calculationId++; // Increment to invalidate previous calculation
                isCalculating = false; // Reset flag immediately so button can be clicked again
            }
            
            const startAddress = document.getElementById('startAddress').value.trim();
            const destAddress = document.getElementById('destinationAddress').value.trim();
            const departureTime = document.getElementById('departureTime').value;

            if (!startAddress || !destAddress || !departureTime) {
                alert('Please fill in all required fields');
                return;
            }

            if (vehicleType === 'truck') {
                truckSpecs.totalWeight = parseFloat(document.getElementById('totalWeight').value) || 0;
                truckSpecs.axleLoad = parseFloat(document.getElementById('axleLoad').value) || 0;
                truckSpecs.numAxles = parseInt(document.getElementById('numAxles').value) || 2;

                if (truckSpecs.totalWeight <= 0 || truckSpecs.axleLoad <= 0) {
                    alert('Please enter valid truck weight and axle load');
                    return;
                }
            }

            const loadingDiv = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            const calculateBtn = document.getElementById('calculateBtn');

            // Store current calculation ID to check if this calculation is still valid
            const currentCalculationId = ++calculationId;
            isCalculating = true;

            try {
                loadingDiv.style.display = 'block';
                calculateBtn.disabled = true;
                clearMap();

                // Geocode addresses
                loadingText.textContent = 'Geocoding start address...';
                const startCoords = await geocodeAddress(startAddress);
                
                // Check if calculation was cancelled
                if (currentCalculationId !== calculationId) {
                    console.log('Calculation cancelled during geocoding');
                    return;
                }
                
                await delay(1000); // Rate limiting for Nominatim

                loadingText.textContent = 'Geocoding destination address...';
                const destCoords = await geocodeAddress(destAddress);
                
                // Check if calculation was cancelled
                if (currentCalculationId !== calculationId) {
                    console.log('Calculation cancelled during geocoding');
                    return;
                }

                // Check countries for start, end, and via points to determine route country
                // Batch country lookups with delays only between Nominatim calls
                loadingText.textContent = 'Checking route countries...';
                const startCountry = await getCountry(startCoords.lat, startCoords.lon);
                await delay(1000); // Rate limiting for Nominatim
                const destCountry = await getCountry(destCoords.lat, destCoords.lon);
                
                // Check via points countries (with rate limiting)
                const viaCountries = [];
                for (let i = 0; i < viaPoints.length; i++) {
                    await delay(1000); // Rate limiting for Nominatim
                    const viaCountry = await getCountry(viaPoints[i].lat, viaPoints[i].lon);
                    viaCountries.push(viaCountry);
                }
                
                // Determine if route stays within one country
                const allCountries = [startCountry, destCountry, ...viaCountries];
                const uniqueCountries = [...new Set(allCountries.filter(c => c !== 'Unknown'))];
                const routeCountry = uniqueCountries.length === 1 ? uniqueCountries[0] : null;
                
                // Check if calculation was cancelled
                if (currentCalculationId !== calculationId) {
                    console.log('Calculation cancelled during country check');
                    return;
                }

                // Get route (with via points if any)
                // For hikers and cyclists, try to find safer routes that avoid unsafe roads
                loadingText.textContent = 'Calculating route...';
                let route;
                if (vehicleType === 'hiker' || vehicleType === 'bike') {
                    loadingText.textContent = 'Finding safest route (avoiding unsafe roads)...';
                    route = await findSaferRoute(
                        startCoords.lat, startCoords.lon,
                        destCoords.lat, destCoords.lon,
                        viaPoints,
                        vehicleType
                    );
                } else {
                    route = await getRoute(
                        startCoords.lat, startCoords.lon,
                        destCoords.lat, destCoords.lon,
                        viaPoints
                    );
                }
                
                // Check if calculation was cancelled after route calculation
                if (currentCalculationId !== calculationId) {
                    console.log('Calculation cancelled after route calculation');
                    return;
                }

                // For hiking, search for hiking routes
                if (vehicleType === 'hiker') {
                    loadingText.textContent = 'Searching for hiking routes...';
                    const hikingRoutes = await findHikingRoutes(
                        startCoords.lat, startCoords.lon,
                        destCoords.lat, destCoords.lon
                    );
                    // Note: Hiking routes found but using OSRM foot profile for routing
                    // Could be used for display or alternative routing in future
                }

                // Draw route on map
                const coordinates = route.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                const routeColor = VEHICLE_COLORS[vehicleType] || '#3498db';
                routePolyline = L.polyline(coordinates, {
                    color: routeColor,
                    weight: 4,
                    opacity: 0.7
                }).addTo(map);

                map.fitBounds(routePolyline.getBounds(), { padding: [50, 50] });

                // Add start and end markers
                addMarker(startCoords.lat, startCoords.lon, 'start', `<strong>Start</strong><br>${startCoords.displayName}`);
                addMarker(destCoords.lat, destCoords.lon, 'end', `<strong>Destination</strong><br>${destCoords.displayName}`);

                // Check route safety for hikers and cyclists
                let safetyWarnings = [];
                if (vehicleType === 'hiker' || vehicleType === 'bike') {
                    loadingText.textContent = 'Checking route safety...';
                    safetyWarnings = await checkRouteSafety(route, vehicleType);
                    
                    // Add safety warning markers
                    safetyWarnings.forEach(warning => {
                        addMarker(
                            warning.lat, warning.lon, 'axle-warning',
                            `<strong>Safety Warning</strong><br>${warning.message}<br>Road: ${warning.roadName || warning.roadType}<br>Type: ${warning.roadType}`
                        );
                    });
                }

                // Calculate rest stops
                // Check if calculation was cancelled
                if (currentCalculationId !== calculationId) {
                    console.log('Calculation cancelled before rest stops');
                    return;
                }
                
                loadingText.textContent = 'Calculating rest stops...';
                const restStops = calculateRestStops(route, departureTime);

                // Get countries and find parking/rest spots
                const countries = [];
                const axleWarnings = [];

                loadingText.textContent = 'Finding rest spots and checking restrictions...';

                for (let i = 0; i < restStops.length; i++) {
                    // Check if calculation was cancelled during loop
                    if (currentCalculationId !== calculationId) {
                        console.log(`Calculation cancelled during rest stop processing (${i + 1}/${restStops.length})`);
                        return;
                    }
                    
                    const stop = restStops[i];
                    loadingText.textContent = `Processing rest stop ${i + 1} of ${restStops.length}...`;

                    // Get country (for trucks/cars) - use cache when possible
                    if (vehicleType !== 'hiker') {
                        const country = await getCountry(stop.lat, stop.lon, true); // Skip delay when processing multiple stops
                        countries.push(country);
                        stop.country = country;
                    }

                    // Check axle load restrictions (trucks only)
                    if (vehicleType === 'truck') {
                        const warnings = await checkAxleLoadRestrictions(stop.lat, stop.lon);
                        warnings.forEach(warning => {
                            if (!axleWarnings.find(w => w.lat === warning.lat && w.lon === warning.lon)) {
                                axleWarnings.push(warning);
                                addMarker(
                                    warning.lat, warning.lon, 'axle-warning',
                                    `<strong>‚ö†Ô∏è Axle Load Warning</strong><br>${warning.message}<br>Road: ${warning.highway}`
                                );
                            }
                        });
                    }

                    // Find parking/rest spots and water points
                    if (vehicleType === 'hiker' || vehicleType === 'bike') {
                        // Find water points for hiking and cycling
                        const waterPoints = await findDrinkingWater(stop.lat, stop.lon, 2000, routeCountry);
                        // Filter to ensure minimum 4km distance between water points
                        const filteredWaterPoints = filterWaterPointsByDistance(waterPoints, 4);
                        filteredWaterPoints.forEach(water => {
                            const popupContent = water.note 
                                ? `<strong>${water.name}</strong><br>Warning: ${water.note}<br>Coordinates: ${water.lat.toFixed(4)}, ${water.lon.toFixed(4)}`
                                : `<strong>${water.name}</strong><br>Coordinates: ${water.lat.toFixed(4)}, ${water.lon.toFixed(4)}`;
                            addMarker(water.lat, water.lon, 'water', popupContent);
                        });

                        // Find huts and shelters near daily segments and rest stops
                        if (stop.type === 'daily-segment' || stop.type === 'segment-break' || stop.type === 'hiker-rest' || stop.type === 'hiker-rest-alt') {
                            const restSpots = await findHikerRestSpots(stop.lat, stop.lon, 3000, routeCountry);
                            stop.restSpots = restSpots;

                            // Prioritize huts: alpine_hut, wilderness_hut, basic_hut, then other shelters
                            const huts = restSpots.filter(s => 
                                s.type === 'alpine_hut' || 
                                s.type === 'wilderness_hut' || 
                                s.type === 'basic_hut'
                            );
                            const otherShelters = restSpots.filter(s => 
                                s.type !== 'alpine_hut' && 
                                s.type !== 'wilderness_hut' && 
                                s.type !== 'basic_hut'
                            );
                            
                            // Combine and filter by minimum distance (1300m)
                            const allSpots = [...huts, ...otherShelters];
                            const filteredSpots = filterHutsByDistance(allSpots, 1.3);
                            
                            // Show up to 5 huts/shelters (prioritize huts, but respect distance)
                            const spotsToShow = filteredSpots.slice(0, 5);
                            
                            spotsToShow.forEach(spot => {
                                let typeLabel = spot.type;
                                if (spot.type === 'alpine_hut') typeLabel = 'Alpine Hut';
                                else if (spot.type === 'wilderness_hut') typeLabel = 'Wilderness Hut';
                                else if (spot.type === 'basic_hut') typeLabel = 'Basic Hut (Unlocked)';
                                else if (spot.type === 'shelter') typeLabel = 'Shelter';
                                
                                addMarker(
                                    spot.lat, spot.lon, 'parking',
                                    `<strong>${typeLabel}</strong><br>${spot.name}<br>Coordinates: ${spot.lat.toFixed(4)}, ${spot.lon.toFixed(4)}`
                                );
                            });
                        }

                        // Add daily segment and rest markers
                        if (stop.type === 'daily-segment') {
                            const popupContent = vehicleType === 'hiker'
                                ? `<strong>Day ${stop.day} End</strong><br>Suggested maximum: 40 km per day<br>Distance: ${stop.distance.toFixed(2)} km<br>Coordinates: ${stop.lat.toFixed(4)}, ${stop.lon.toFixed(4)}`
                                : `<strong>Day ${stop.day} End</strong><br>Suggested maximum: 70 km per day<br>Distance: ${stop.distance.toFixed(2)} km<br>Coordinates: ${stop.lat.toFixed(4)}, ${stop.lon.toFixed(4)}`;
                            addMarker(stop.lat, stop.lon, 'daily-segment', popupContent);
                        } else if (stop.type === 'segment-break') {
                            const popupContent = `<strong>Segment ${stop.segment} Break</strong><br>17 km segment break<br>Distance: ${stop.distance.toFixed(2)} km<br>Coordinates: ${stop.lat.toFixed(4)}, ${stop.lon.toFixed(4)}`;
                            addMarker(stop.lat, stop.lon, 'segment-break', popupContent);
                        } else if (stop.type === 'hiker-rest' || stop.type === 'hiker-rest-alt') {
                            const popupContent = `<strong>${stop.type === 'hiker-rest' ? 'Rest (11.295 km)' : 'Alternative Rest (2.275 km)'}</strong><br>Distance: ${stop.distance.toFixed(2)} km<br>Coordinates: ${stop.lat.toFixed(4)}, ${stop.lon.toFixed(4)}`;
                            addMarker(stop.lat, stop.lon, stop.type, popupContent);
                        }
                    } else {
                        // Trucks/Cars: find parking spots for daily and weekly rests
                        if (stop.type === 'daily' || stop.type === 'weekly') {
                            const parkingSpots = await findParkingSpots(stop.lat, stop.lon, 3000, routeCountry);
                            stop.parkingSpots = parkingSpots;

                            parkingSpots.slice(0, 3).forEach(spot => {
                                const rule = COUNTRY_RULES[stop.country] || {};
                                addMarker(
                                    spot.lat, spot.lon, 'parking',
                                    `<strong>Suitable Parking</strong><br>Road: ${spot.name} (${spot.highway})<br>Country: ${stop.country}<br>${rule.rules ? `Rules: ${rule.rules}` : ''}<br>Coordinates: ${spot.lat.toFixed(4)}, ${spot.lon.toFixed(4)}`
                                );
                            });
                        }

                        // Add rest stop marker
                        const rule = COUNTRY_RULES[stop.country] || {};
                        const popupContent = `
                            <strong>${stop.type === 'break' ? '45-min Break' : stop.type === 'daily' ? 'Daily Rest (11h)' : 'Weekly Rest (45h)'}</strong><br>
                            Time: ${stop.time.toLocaleString()}<br>
                            Country: ${stop.country}<br>
                            ${rule.rules ? `Rules: ${rule.rules}` : ''}<br>
                            Distance: ${stop.distance.toFixed(1)} km<br>
                            Coordinates: ${stop.lat.toFixed(4)}, ${stop.lon.toFixed(4)}
                        `;
                        addMarker(stop.lat, stop.lon, stop.type, popupContent);
                    }

                    // Removed unnecessary delay - rate limiting handled by individual API calls
                }

                // Water points and huts along the route (for hiking and cycling)
                if (vehicleType === 'hiker' || vehicleType === 'bike') {
                    loadingText.textContent = 'Finding water points and huts along route...';
                    // Sample points along the route for water and hut search
                    const samplePoints = [];
                    for (let i = 0; i < coordinates.length; i += Math.max(10, Math.floor(coordinates.length / 20))) {
                        samplePoints.push(coordinates[i]);
                    }
                    
                    for (let i = 0; i < samplePoints.length; i++) {
                        const [lat, lon] = samplePoints[i];
                        
                        // Find water points
                        const waterPoints = await findDrinkingWater(lat, lon, 2000, routeCountry);
                        // Filter to ensure minimum 4km distance between water points
                        const filteredWaterPoints = filterWaterPointsByDistance(waterPoints, 4);
                        filteredWaterPoints.forEach(water => {
                            const popupContent = water.note 
                                ? `<strong>${water.name}</strong><br>Warning: ${water.note}<br>Coordinates: ${water.lat.toFixed(4)}, ${water.lon.toFixed(4)}`
                                : `<strong>${water.name}</strong><br>Coordinates: ${water.lat.toFixed(4)}, ${water.lon.toFixed(4)}`;
                            addMarker(water.lat, water.lon, 'water', popupContent);
                        });
                        
                        // Find huts and shelters
                        const huts = await findHikerRestSpots(lat, lon, 3000, routeCountry);
                        const priorityHuts = huts.filter(h => 
                            h.type === 'alpine_hut' || 
                            h.type === 'wilderness_hut' || 
                            h.type === 'basic_hut'
                        );
                        // Filter by minimum distance (1300m)
                        const filteredHuts = filterHutsByDistance(priorityHuts, 1.3);
                        filteredHuts.slice(0, 2).forEach(spot => {
                            let typeLabel = spot.type;
                            if (spot.type === 'alpine_hut') typeLabel = 'Alpine Hut';
                            else if (spot.type === 'wilderness_hut') typeLabel = 'Wilderness Hut';
                            else if (spot.type === 'basic_hut') typeLabel = 'Basic Hut (Unlocked)';
                            
                            addMarker(
                                spot.lat, spot.lon, 'parking',
                                `<strong>${typeLabel}</strong><br>${spot.name}<br>Coordinates: ${spot.lat.toFixed(4)}, ${spot.lon.toFixed(4)}`
                            );
                        });
                        
                        await delay(500); // Rate limiting
                    }
                }

                // Final check before saving route data
                if (currentCalculationId !== calculationId) {
                    console.log('Calculation cancelled before saving route data');
                    return;
                }

                // Final check before saving route data and updating UI
                if (currentCalculationId !== calculationId) {
                    console.log('Calculation cancelled before saving route data');
                    return;
                }

                // Update UI
                updateRouteSummary(route, startCoords.displayName, destCoords.displayName);
                updateRestStopsList(restStops);
                updateAxleWarnings(axleWarnings);
                updateSafetyWarnings(safetyWarnings);
                updateCountryWarnings(countries);

                routeData = { route, restStops, startCoords, destCoords, viaPoints, safetyWarnings, vehicleType };

            } catch (error) {
                // Only show error if this is still the current calculation
                if (currentCalculationId === calculationId) {
                    alert(`Error: ${error.message}`);
                    console.error(error);
                } else {
                    console.log('Error in cancelled calculation, ignoring:', error.message);
                }
            } finally {
                // Only update UI if this is still the current calculation
                if (currentCalculationId === calculationId) {
                    isCalculating = false;
                    loadingDiv.style.display = 'none';
                    calculateBtn.disabled = false;
                } else {
                    // If calculation was cancelled, still re-enable button but don't hide loading
                    // (new calculation will handle UI)
                    isCalculating = false;
                    calculateBtn.disabled = false;
                }
            }
        }

        // Export route to GPX file
        function exportToGPX() {
            if (!routeData) {
                alert('No route calculated yet. Please calculate a route first.');
                return;
            }

            const route = routeData.route;
            const restStops = routeData.restStops || [];
            const startCoords = routeData.startCoords;
            const destCoords = routeData.destCoords;
            const viaPoints = routeData.viaPoints || [];
            const safetyWarnings = routeData.safetyWarnings || [];
            const vehicleType = routeData.vehicleType || 'unknown';

            // Get all waypoints data
            const allWaypoints = [];
            
            // Start point
            allWaypoints.push({
                lat: startCoords.lat,
                lon: startCoords.lon,
                name: 'Start: ' + startCoords.displayName,
                type: 'start'
            });

            // Via points
            viaPoints.forEach((via, index) => {
                allWaypoints.push({
                    lat: via.lat,
                    lon: via.lon,
                    name: `Via Point ${index + 1}: ${via.name}`,
                    type: 'via'
                });
            });

            // End point
            allWaypoints.push({
                lat: destCoords.lat,
                lon: destCoords.lon,
                name: 'Destination: ' + destCoords.displayName,
                type: 'destination'
            });

            // Rest stops
            restStops.forEach((stop, index) => {
                let stopName = '';
                if (vehicleType === 'hiker') {
                    if (stop.type === 'daily-segment') {
                        stopName = `Day ${stop.day} End (40 km)`;
                    } else if (stop.type === 'hiker-rest') {
                        stopName = `Rest ${index + 1} (11.295 km)`;
                    } else if (stop.type === 'hiker-rest-alt') {
                        stopName = `Alt Rest ${index + 1} (2.275 km)`;
                    }
                } else if (vehicleType === 'bike') {
                    if (stop.type === 'daily-segment') {
                        stopName = `Day ${stop.day} End (70 km)`;
                    } else if (stop.type === 'segment-break') {
                        stopName = `Segment ${stop.segment} Break (17 km)`;
                    }
                } else {
                    if (stop.type === 'break') {
                        stopName = `Break ${index + 1} (45 min)`;
                    } else if (stop.type === 'daily') {
                        stopName = `Daily Rest ${index + 1} (11h)`;
                    } else if (stop.type === 'weekly') {
                        stopName = `Weekly Rest (45h)`;
                    }
                }
                
                if (stopName) {
                    allWaypoints.push({
                        lat: stop.lat,
                        lon: stop.lon,
                        name: stopName,
                        type: stop.type,
                        distance: stop.distance
                    });
                }
            });

            // Generate GPX XML
            const gpx = generateGPX(route, allWaypoints, safetyWarnings, vehicleType);
            
            // Create download
            const blob = new Blob([gpx], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_${vehicleType}_${new Date().toISOString().split('T')[0]}.gpx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Generate GPX XML content
        function generateGPX(route, waypoints, safetyWarnings, vehicleType) {
            const coordinates = route.routes[0].geometry.coordinates;
            const distance = (route.routes[0].distance / 1000).toFixed(2);
            const duration = route.routes[0].duration;
            const hours = Math.floor(duration / 3600);
            const minutes = Math.floor((duration % 3600) / 60);
            
            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Route Planner" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <name>Route - ${vehicleType}</name>
    <desc>Route planned for ${vehicleType}. Distance: ${distance} km, Duration: ${hours}h ${minutes}m</desc>
    <time>${new Date().toISOString()}</time>
  </metadata>
`;

            // Add waypoints
            waypoints.forEach(wpt => {
                gpx += `  <wpt lat="${wpt.lat.toFixed(6)}" lon="${wpt.lon.toFixed(6)}">
    <name><![CDATA[${wpt.name}]]></name>
    <type>${wpt.type}</type>
    ${wpt.distance ? `<cmt>Distance: ${wpt.distance.toFixed(2)} km</cmt>` : ''}
  </wpt>
`;
            });

            // Add safety warnings as waypoints
            safetyWarnings.forEach((warning, index) => {
                gpx += `  <wpt lat="${warning.lat.toFixed(6)}" lon="${warning.lon.toFixed(6)}">
    <name><![CDATA[Safety Warning ${index + 1}: ${warning.roadType}]]></name>
    <type>safety_warning</type>
    <cmt><![CDATA[${warning.message} - ${warning.roadName || 'Unnamed road'}]]></cmt>
  </wpt>
`;
            });

            // Add track (the actual route)
            gpx += `  <trk>
    <name>Route Track</name>
    <desc>Main route track for ${vehicleType}</desc>
    <trkseg>
`;
            
            coordinates.forEach(coord => {
                const [lon, lat] = coord;
                gpx += `      <trkpt lat="${lat.toFixed(6)}" lon="${lon.toFixed(6)}"></trkpt>
`;
            });

            gpx += `    </trkseg>
  </trk>
</gpx>`;

            return gpx;
        }
    </script>
</body>
</html>
